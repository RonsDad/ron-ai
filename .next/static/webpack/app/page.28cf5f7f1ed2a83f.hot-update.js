"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/use-computer-agent.ts":
/*!*****************************************!*\
  !*** ./src/hooks/use-computer-agent.ts ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useComputerAgent: () => (/* binding */ useComputerAgent)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__ useComputerAgent auto */ \nfunction useComputerAgent() {\n    const [agentState, setAgentState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        isActive: false,\n        currentTask: null,\n        liveUrl: null,\n        sessionId: null\n    });\n    const startAgent = async (task, url)=>{\n        try {\n            // Call browser-use backend to create session with LiveURL\n            const response = await fetch('/api/browser-use/session/create-with-url', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    url: url || 'https://duckduckgo.com',\n                    timeout_ms: 600000\n                })\n            });\n            if (!response.ok) {\n                throw new Error(\"Failed to create browser session: \".concat(response.status));\n            }\n            const data = await response.json();\n            const sessionId = data.result.session_id;\n            const liveUrl = data.result.live_url;\n            setAgentState({\n                isActive: true,\n                currentTask: task,\n                liveUrl: liveUrl,\n                sessionId: sessionId\n            });\n            // Now execute the task on the browser-use agent\n            if (task && task !== \"Computer Use Agent Active\") {\n                console.log(\"Executing browser task: \".concat(task));\n                try {\n                    const taskResponse = await fetch(\"/api/browser-use/session/\".concat(sessionId, \"/task\"), {\n                        method: 'POST',\n                        headers: {\n                            'Content-Type': 'application/json'\n                        },\n                        body: JSON.stringify({\n                            task\n                        })\n                    });\n                    if (!taskResponse.ok) {\n                        console.error(\"Failed to execute task: \".concat(taskResponse.status));\n                    } else {\n                        const taskResult = await taskResponse.json();\n                        console.log('Task execution result:', taskResult);\n                    }\n                } catch (taskError) {\n                    console.error('Error executing browser task:', taskError);\n                }\n            }\n        } catch (error) {\n            console.error('Failed to start browser agent:', error);\n            // Fallback to just showing UI without LiveURL\n            const sessionId = \"cua_\".concat(Date.now());\n            setAgentState({\n                isActive: true,\n                currentTask: task,\n                liveUrl: null,\n                sessionId\n            });\n        }\n    };\n    const stopAgent = async ()=>{\n        if (agentState.sessionId) {\n            try {\n                // Close browser session\n                await fetch(\"/api/browser-use/session/\".concat(agentState.sessionId, \"/close\"), {\n                    method: 'DELETE'\n                });\n            } catch (error) {\n                console.error('Failed to close browser session:', error);\n            }\n        }\n        setAgentState({\n            isActive: false,\n            currentTask: null,\n            liveUrl: null,\n            sessionId: null\n        });\n    };\n    const updateTask = (task)=>{\n        setAgentState((prev)=>({\n                ...prev,\n                currentTask: task\n            }));\n    };\n    const updateUrl = (url)=>{\n        setAgentState((prev)=>({\n                ...prev,\n                liveUrl: url\n            }));\n    };\n    const executeTask = async (task)=>{\n        if (!agentState.sessionId) {\n            throw new Error('No active browser session');\n        }\n        try {\n            const taskResponse = await fetch(\"/api/browser-use/session/\".concat(agentState.sessionId, \"/task\"), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    task\n                })\n            });\n            if (!taskResponse.ok) {\n                throw new Error(\"Failed to execute task: \".concat(taskResponse.status));\n            }\n            const taskResult = await taskResponse.json();\n            console.log('Task execution result:', taskResult);\n            // Update current task\n            setAgentState((prev)=>({\n                    ...prev,\n                    currentTask: task\n                }));\n            return taskResult;\n        } catch (error) {\n            console.error('Error executing browser task:', error);\n            throw error;\n        }\n    };\n    return {\n        agentState,\n        startAgent,\n        stopAgent,\n        updateTask,\n        updateUrl,\n        executeTask\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2UtY29tcHV0ZXItYWdlbnQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O3NFQUVnQztBQVN6QixTQUFTQztJQUNkLE1BQU0sQ0FBQ0MsWUFBWUMsY0FBYyxHQUFHSCwrQ0FBUUEsQ0FBcUI7UUFDL0RJLFVBQVU7UUFDVkMsYUFBYTtRQUNiQyxTQUFTO1FBQ1RDLFdBQVc7SUFDYjtJQUVBLE1BQU1DLGFBQWEsT0FBT0MsTUFBY0M7UUFDdEMsSUFBSTtZQUNGLDBEQUEwRDtZQUMxRCxNQUFNQyxXQUFXLE1BQU1DLE1BQU0sNENBQTRDO2dCQUN2RUMsUUFBUTtnQkFDUkMsU0FBUztvQkFDUCxnQkFBZ0I7Z0JBQ2xCO2dCQUNBQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7b0JBQ25CUCxLQUFLQSxPQUFPO29CQUNaUSxZQUFZO2dCQUNkO1lBQ0Y7WUFFQSxJQUFJLENBQUNQLFNBQVNRLEVBQUUsRUFBRTtnQkFDaEIsTUFBTSxJQUFJQyxNQUFNLHFDQUFxRCxPQUFoQlQsU0FBU1UsTUFBTTtZQUN0RTtZQUVBLE1BQU1DLE9BQU8sTUFBTVgsU0FBU1ksSUFBSTtZQUNoQyxNQUFNaEIsWUFBWWUsS0FBS0UsTUFBTSxDQUFDQyxVQUFVO1lBQ3hDLE1BQU1uQixVQUFVZ0IsS0FBS0UsTUFBTSxDQUFDRSxRQUFRO1lBRXBDdkIsY0FBYztnQkFDWkMsVUFBVTtnQkFDVkMsYUFBYUk7Z0JBQ2JILFNBQVNBO2dCQUNUQyxXQUFXQTtZQUNiO1lBRUEsZ0RBQWdEO1lBQ2hELElBQUlFLFFBQVFBLFNBQVMsNkJBQTZCO2dCQUNoRGtCLFFBQVFDLEdBQUcsQ0FBQywyQkFBZ0MsT0FBTG5CO2dCQUV2QyxJQUFJO29CQUNGLE1BQU1vQixlQUFlLE1BQU1qQixNQUFNLDRCQUFzQyxPQUFWTCxXQUFVLFVBQVE7d0JBQzdFTSxRQUFRO3dCQUNSQyxTQUFTOzRCQUNQLGdCQUFnQjt3QkFDbEI7d0JBQ0FDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQzs0QkFBRVI7d0JBQUs7b0JBQzlCO29CQUVBLElBQUksQ0FBQ29CLGFBQWFWLEVBQUUsRUFBRTt3QkFDcEJRLFFBQVFHLEtBQUssQ0FBQywyQkFBK0MsT0FBcEJELGFBQWFSLE1BQU07b0JBQzlELE9BQU87d0JBQ0wsTUFBTVUsYUFBYSxNQUFNRixhQUFhTixJQUFJO3dCQUMxQ0ksUUFBUUMsR0FBRyxDQUFDLDBCQUEwQkc7b0JBQ3hDO2dCQUNGLEVBQUUsT0FBT0MsV0FBVztvQkFDbEJMLFFBQVFHLEtBQUssQ0FBQyxpQ0FBaUNFO2dCQUNqRDtZQUNGO1FBRUYsRUFBRSxPQUFPRixPQUFPO1lBQ2RILFFBQVFHLEtBQUssQ0FBQyxrQ0FBa0NBO1lBQ2hELDhDQUE4QztZQUM5QyxNQUFNdkIsWUFBWSxPQUFrQixPQUFYMEIsS0FBS0MsR0FBRztZQUNqQy9CLGNBQWM7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLGFBQWFJO2dCQUNiSCxTQUFTO2dCQUNUQztZQUNGO1FBQ0Y7SUFDRjtJQUVBLE1BQU00QixZQUFZO1FBQ2hCLElBQUlqQyxXQUFXSyxTQUFTLEVBQUU7WUFDeEIsSUFBSTtnQkFDRix3QkFBd0I7Z0JBQ3hCLE1BQU1LLE1BQU0sNEJBQWlELE9BQXJCVixXQUFXSyxTQUFTLEVBQUMsV0FBUztvQkFDcEVNLFFBQVE7Z0JBQ1Y7WUFDRixFQUFFLE9BQU9pQixPQUFPO2dCQUNkSCxRQUFRRyxLQUFLLENBQUMsb0NBQW9DQTtZQUNwRDtRQUNGO1FBRUEzQixjQUFjO1lBQ1pDLFVBQVU7WUFDVkMsYUFBYTtZQUNiQyxTQUFTO1lBQ1RDLFdBQVc7UUFDYjtJQUNGO0lBRUEsTUFBTTZCLGFBQWEsQ0FBQzNCO1FBQ2xCTixjQUFjLENBQUNrQyxPQUFVO2dCQUN2QixHQUFHQSxJQUFJO2dCQUNQaEMsYUFBYUk7WUFDZjtJQUNGO0lBRUEsTUFBTTZCLFlBQVksQ0FBQzVCO1FBQ2pCUCxjQUFjLENBQUNrQyxPQUFVO2dCQUN2QixHQUFHQSxJQUFJO2dCQUNQL0IsU0FBU0k7WUFDWDtJQUNGO0lBRUEsTUFBTTZCLGNBQWMsT0FBTzlCO1FBQ3pCLElBQUksQ0FBQ1AsV0FBV0ssU0FBUyxFQUFFO1lBQ3pCLE1BQU0sSUFBSWEsTUFBTTtRQUNsQjtRQUVBLElBQUk7WUFDRixNQUFNUyxlQUFlLE1BQU1qQixNQUFNLDRCQUFpRCxPQUFyQlYsV0FBV0ssU0FBUyxFQUFDLFVBQVE7Z0JBQ3hGTSxRQUFRO2dCQUNSQyxTQUFTO29CQUNQLGdCQUFnQjtnQkFDbEI7Z0JBQ0FDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztvQkFBRVI7Z0JBQUs7WUFDOUI7WUFFQSxJQUFJLENBQUNvQixhQUFhVixFQUFFLEVBQUU7Z0JBQ3BCLE1BQU0sSUFBSUMsTUFBTSwyQkFBK0MsT0FBcEJTLGFBQWFSLE1BQU07WUFDaEU7WUFFQSxNQUFNVSxhQUFhLE1BQU1GLGFBQWFOLElBQUk7WUFDMUNJLFFBQVFDLEdBQUcsQ0FBQywwQkFBMEJHO1lBRXRDLHNCQUFzQjtZQUN0QjVCLGNBQWMsQ0FBQ2tDLE9BQVU7b0JBQ3ZCLEdBQUdBLElBQUk7b0JBQ1BoQyxhQUFhSTtnQkFDZjtZQUVBLE9BQU9zQjtRQUNULEVBQUUsT0FBT0QsT0FBTztZQUNkSCxRQUFRRyxLQUFLLENBQUMsaUNBQWlDQTtZQUMvQyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxPQUFPO1FBQ0w1QjtRQUNBTTtRQUNBMkI7UUFDQUM7UUFDQUU7UUFDQUM7SUFDRjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvdGltaHVudGVyL3Jvbi1haS9zcmMvaG9va3MvdXNlLWNvbXB1dGVyLWFnZW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiXG5cbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCJcblxuaW50ZXJmYWNlIENvbXB1dGVyQWdlbnRTdGF0ZSB7XG4gIGlzQWN0aXZlOiBib29sZWFuXG4gIGN1cnJlbnRUYXNrOiBzdHJpbmcgfCBudWxsXG4gIGxpdmVVcmw6IHN0cmluZyB8IG51bGxcbiAgc2Vzc2lvbklkOiBzdHJpbmcgfCBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VDb21wdXRlckFnZW50KCkge1xuICBjb25zdCBbYWdlbnRTdGF0ZSwgc2V0QWdlbnRTdGF0ZV0gPSB1c2VTdGF0ZTxDb21wdXRlckFnZW50U3RhdGU+KHtcbiAgICBpc0FjdGl2ZTogZmFsc2UsXG4gICAgY3VycmVudFRhc2s6IG51bGwsXG4gICAgbGl2ZVVybDogbnVsbCxcbiAgICBzZXNzaW9uSWQ6IG51bGwsXG4gIH0pXG5cbiAgY29uc3Qgc3RhcnRBZ2VudCA9IGFzeW5jICh0YXNrOiBzdHJpbmcsIHVybD86IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDYWxsIGJyb3dzZXItdXNlIGJhY2tlbmQgdG8gY3JlYXRlIHNlc3Npb24gd2l0aCBMaXZlVVJMXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2Jyb3dzZXItdXNlL3Nlc3Npb24vY3JlYXRlLXdpdGgtdXJsJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgXG4gICAgICAgICAgdXJsOiB1cmwgfHwgJ2h0dHBzOi8vZHVja2R1Y2tnby5jb20nLCBcbiAgICAgICAgICB0aW1lb3V0X21zOiA2MDAwMDAgXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBicm93c2VyIHNlc3Npb246ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgIGNvbnN0IHNlc3Npb25JZCA9IGRhdGEucmVzdWx0LnNlc3Npb25faWRcbiAgICAgIGNvbnN0IGxpdmVVcmwgPSBkYXRhLnJlc3VsdC5saXZlX3VybFxuICAgICAgXG4gICAgICBzZXRBZ2VudFN0YXRlKHtcbiAgICAgICAgaXNBY3RpdmU6IHRydWUsXG4gICAgICAgIGN1cnJlbnRUYXNrOiB0YXNrLFxuICAgICAgICBsaXZlVXJsOiBsaXZlVXJsLFxuICAgICAgICBzZXNzaW9uSWQ6IHNlc3Npb25JZCxcbiAgICAgIH0pXG5cbiAgICAgIC8vIE5vdyBleGVjdXRlIHRoZSB0YXNrIG9uIHRoZSBicm93c2VyLXVzZSBhZ2VudFxuICAgICAgaWYgKHRhc2sgJiYgdGFzayAhPT0gXCJDb21wdXRlciBVc2UgQWdlbnQgQWN0aXZlXCIpIHtcbiAgICAgICAgY29uc29sZS5sb2coYEV4ZWN1dGluZyBicm93c2VyIHRhc2s6ICR7dGFza31gKVxuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB0YXNrUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9icm93c2VyLXVzZS9zZXNzaW9uLyR7c2Vzc2lvbklkfS90YXNrYCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB0YXNrIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIXRhc2tSZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGV4ZWN1dGUgdGFzazogJHt0YXNrUmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRhc2tSZXN1bHQgPSBhd2FpdCB0YXNrUmVzcG9uc2UuanNvbigpXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnVGFzayBleGVjdXRpb24gcmVzdWx0OicsIHRhc2tSZXN1bHQpXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoICh0YXNrRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBleGVjdXRpbmcgYnJvd3NlciB0YXNrOicsIHRhc2tFcnJvcilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzdGFydCBicm93c2VyIGFnZW50OicsIGVycm9yKVxuICAgICAgLy8gRmFsbGJhY2sgdG8ganVzdCBzaG93aW5nIFVJIHdpdGhvdXQgTGl2ZVVSTFxuICAgICAgY29uc3Qgc2Vzc2lvbklkID0gYGN1YV8ke0RhdGUubm93KCl9YFxuICAgICAgc2V0QWdlbnRTdGF0ZSh7XG4gICAgICAgIGlzQWN0aXZlOiB0cnVlLFxuICAgICAgICBjdXJyZW50VGFzazogdGFzayxcbiAgICAgICAgbGl2ZVVybDogbnVsbCxcbiAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBjb25zdCBzdG9wQWdlbnQgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKGFnZW50U3RhdGUuc2Vzc2lvbklkKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBDbG9zZSBicm93c2VyIHNlc3Npb25cbiAgICAgICAgYXdhaXQgZmV0Y2goYC9hcGkvYnJvd3Nlci11c2Uvc2Vzc2lvbi8ke2FnZW50U3RhdGUuc2Vzc2lvbklkfS9jbG9zZWAsIHtcbiAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNsb3NlIGJyb3dzZXIgc2Vzc2lvbjonLCBlcnJvcilcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgc2V0QWdlbnRTdGF0ZSh7XG4gICAgICBpc0FjdGl2ZTogZmFsc2UsXG4gICAgICBjdXJyZW50VGFzazogbnVsbCxcbiAgICAgIGxpdmVVcmw6IG51bGwsXG4gICAgICBzZXNzaW9uSWQ6IG51bGwsXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IHVwZGF0ZVRhc2sgPSAodGFzazogc3RyaW5nKSA9PiB7XG4gICAgc2V0QWdlbnRTdGF0ZSgocHJldikgPT4gKHtcbiAgICAgIC4uLnByZXYsXG4gICAgICBjdXJyZW50VGFzazogdGFzayxcbiAgICB9KSlcbiAgfVxuXG4gIGNvbnN0IHVwZGF0ZVVybCA9ICh1cmw6IHN0cmluZykgPT4ge1xuICAgIHNldEFnZW50U3RhdGUoKHByZXYpID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgbGl2ZVVybDogdXJsLFxuICAgIH0pKVxuICB9XG5cbiAgY29uc3QgZXhlY3V0ZVRhc2sgPSBhc3luYyAodGFzazogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCFhZ2VudFN0YXRlLnNlc3Npb25JZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY3RpdmUgYnJvd3NlciBzZXNzaW9uJylcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgdGFza1Jlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvYnJvd3Nlci11c2Uvc2Vzc2lvbi8ke2FnZW50U3RhdGUuc2Vzc2lvbklkfS90YXNrYCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdGFzayB9KVxuICAgICAgfSlcbiAgICAgIFxuICAgICAgaWYgKCF0YXNrUmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZXhlY3V0ZSB0YXNrOiAke3Rhc2tSZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgdGFza1Jlc3VsdCA9IGF3YWl0IHRhc2tSZXNwb25zZS5qc29uKClcbiAgICAgIGNvbnNvbGUubG9nKCdUYXNrIGV4ZWN1dGlvbiByZXN1bHQ6JywgdGFza1Jlc3VsdClcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIGN1cnJlbnQgdGFza1xuICAgICAgc2V0QWdlbnRTdGF0ZSgocHJldikgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgY3VycmVudFRhc2s6IHRhc2ssXG4gICAgICB9KSlcbiAgICAgIFxuICAgICAgcmV0dXJuIHRhc2tSZXN1bHRcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZXhlY3V0aW5nIGJyb3dzZXIgdGFzazonLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhZ2VudFN0YXRlLFxuICAgIHN0YXJ0QWdlbnQsXG4gICAgc3RvcEFnZW50LFxuICAgIHVwZGF0ZVRhc2ssXG4gICAgdXBkYXRlVXJsLFxuICAgIGV4ZWN1dGVUYXNrLFxuICB9XG59XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VDb21wdXRlckFnZW50IiwiYWdlbnRTdGF0ZSIsInNldEFnZW50U3RhdGUiLCJpc0FjdGl2ZSIsImN1cnJlbnRUYXNrIiwibGl2ZVVybCIsInNlc3Npb25JZCIsInN0YXJ0QWdlbnQiLCJ0YXNrIiwidXJsIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInRpbWVvdXRfbXMiLCJvayIsIkVycm9yIiwic3RhdHVzIiwiZGF0YSIsImpzb24iLCJyZXN1bHQiLCJzZXNzaW9uX2lkIiwibGl2ZV91cmwiLCJjb25zb2xlIiwibG9nIiwidGFza1Jlc3BvbnNlIiwiZXJyb3IiLCJ0YXNrUmVzdWx0IiwidGFza0Vycm9yIiwiRGF0ZSIsIm5vdyIsInN0b3BBZ2VudCIsInVwZGF0ZVRhc2siLCJwcmV2IiwidXBkYXRlVXJsIiwiZXhlY3V0ZVRhc2siXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/use-computer-agent.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClaudeAPI: () => (/* binding */ ClaudeAPI),\n/* harmony export */   claudeAPI: () => (/* binding */ claudeAPI),\n/* harmony export */   parseSSEStream: () => (/* binding */ parseSSEStream)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// API service for communicating with Claude agent backend\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || '/api';\nclass ClaudeAPI {\n    async chat(request) {\n        const response = await fetch(\"\".concat(this.baseURL, \"/chat\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(request)\n        });\n        if (!response.ok) {\n            throw new Error(\"API error: \".concat(response.status, \" \").concat(response.statusText));\n        }\n        return response.json();\n    }\n    async chatStream(request) {\n        const response = await fetch(\"\".concat(this.baseURL, \"/chat\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                ...request,\n                stream: true\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"API error: \".concat(response.status, \" \").concat(response.statusText));\n        }\n        if (!response.body) {\n            throw new Error('No response body');\n        }\n        return response.body;\n    }\n    async healthcareAnalyze(task, context) {\n        const response = await fetch(\"\".concat(this.baseURL, \"/healthcare/analyze\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                task,\n                context\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"API error: \".concat(response.status, \" \").concat(response.statusText));\n        }\n        return response.json();\n    }\n    async deepResearch(messages, sessionId, userId) {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/run_sse\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                sessionId,\n                userId,\n                newMessage: {\n                    parts: messages.map((msg)=>({\n                            text: msg.content\n                        })),\n                    role: messages[messages.length - 1].role\n                }\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"API error: \".concat(response.status, \" \").concat(response.statusText));\n        }\n        return response.body;\n    }\n    constructor(baseURL = API_BASE_URL){\n        this.baseURL = baseURL;\n    }\n}\n// Export singleton instance\nconst claudeAPI = new ClaudeAPI();\n// Helper function to parse SSE stream\nasync function* parseSSEStream(stream) {\n    const reader = stream.getReader();\n    const decoder = new TextDecoder();\n    let buffer = '';\n    try {\n        while(true){\n            const { done, value } = await reader.read();\n            if (done) break;\n            buffer += decoder.decode(value, {\n                stream: true\n            });\n            const lines = buffer.split('\\n');\n            buffer = lines.pop() || '';\n            for (const line of lines){\n                if (line.startsWith('data: ')) {\n                    const data = line.slice(6).trim();\n                    if (data && data !== '[DONE]') {\n                        try {\n                            yield JSON.parse(data);\n                        } catch (e) {\n                            console.error('Failed to parse SSE data:', e);\n                        }\n                    }\n                }\n            }\n        }\n    } finally{\n        reader.releaseLock();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LDRCQUE0QjtBQUNyQixNQUFNNkIsWUFBWSxJQUFJbEMsWUFBVztBQUV4QyxzQ0FBc0M7QUFDL0IsZ0JBQWdCbUMsZUFBZWxCLE1BQWtDO0lBQ3RFLE1BQU1tQixTQUFTbkIsT0FBT29CLFNBQVM7SUFDL0IsTUFBTUMsVUFBVSxJQUFJQztJQUNwQixJQUFJQyxTQUFTO0lBRWIsSUFBSTtRQUNGLE1BQU8sS0FBTTtZQUNYLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNTixPQUFPTyxJQUFJO1lBQ3pDLElBQUlGLE1BQU07WUFFVkQsVUFBVUYsUUFBUU0sTUFBTSxDQUFDRixPQUFPO2dCQUFFekIsUUFBUTtZQUFLO1lBQy9DLE1BQU00QixRQUFRTCxPQUFPTSxLQUFLLENBQUM7WUFDM0JOLFNBQVNLLE1BQU1FLEdBQUcsTUFBTTtZQUV4QixLQUFLLE1BQU1DLFFBQVFILE1BQU87Z0JBQ3hCLElBQUlHLEtBQUtDLFVBQVUsQ0FBQyxXQUFXO29CQUM3QixNQUFNQyxPQUFPRixLQUFLRyxLQUFLLENBQUMsR0FBR0MsSUFBSTtvQkFDL0IsSUFBSUYsUUFBUUEsU0FBUyxVQUFVO3dCQUM3QixJQUFJOzRCQUNGLE1BQU16QyxLQUFLNEMsS0FBSyxDQUFDSDt3QkFDbkIsRUFBRSxPQUFPSSxHQUFHOzRCQUNWQyxRQUFRQyxLQUFLLENBQUMsNkJBQTZCRjt3QkFDN0M7b0JBQ0Y7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0YsU0FBVTtRQUNSbEIsT0FBT3FCLFdBQVc7SUFDcEI7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3RpbWh1bnRlci9yb24tYWkvc3JjL2xpYi9hcGkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQVBJIHNlcnZpY2UgZm9yIGNvbW11bmljYXRpbmcgd2l0aCBDbGF1ZGUgYWdlbnQgYmFja2VuZFxuY29uc3QgQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnL2FwaSdcblxuZXhwb3J0IGludGVyZmFjZSBDaGF0TWVzc2FnZSB7XG4gIHJvbGU6ICd1c2VyJyB8ICdhc3Npc3RhbnQnXG4gIGNvbnRlbnQ6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENoYXRSZXF1ZXN0IHtcbiAgbWVzc2FnZXM6IENoYXRNZXNzYWdlW11cbiAgc3lzdGVtX3Byb21wdD86IHN0cmluZ1xuICB0ZW1wZXJhdHVyZT86IG51bWJlclxuICBtYXhfdG9rZW5zPzogbnVtYmVyXG4gIHRvb2xzPzogc3RyaW5nW11cbiAgZW5hYmxlX2NhY2hpbmc/OiBib29sZWFuXG4gIGNhY2hlX3R0bD86IHN0cmluZ1xuICBlbmFibGVfdGhpbmtpbmc/OiBib29sZWFuXG4gIHRoaW5raW5nX2J1ZGdldD86IG51bWJlclxuICBlbmFibGVfY2l0YXRpb25zPzogYm9vbGVhblxuICBzdHJlYW0/OiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdFJlc3BvbnNlIHtcbiAgc3VjY2VzczogYm9vbGVhblxuICByZXNwb25zZToge1xuICAgIGNvbnRlbnQ6IEFycmF5PHtcbiAgICAgIHR5cGU6IHN0cmluZ1xuICAgICAgdGV4dD86IHN0cmluZ1xuICAgICAgdG9vbF91c2U/OiB7XG4gICAgICAgIGlkOiBzdHJpbmdcbiAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgIGlucHV0OiBhbnlcbiAgICAgIH1cbiAgICB9PlxuICAgIHVzYWdlPzoge1xuICAgICAgaW5wdXRfdG9rZW5zOiBudW1iZXJcbiAgICAgIG91dHB1dF90b2tlbnM6IG51bWJlclxuICAgICAgY2FjaGVfY3JlYXRpb25faW5wdXRfdG9rZW5zPzogbnVtYmVyXG4gICAgICBjYWNoZV9yZWFkX2lucHV0X3Rva2Vucz86IG51bWJlclxuICAgIH1cbiAgfVxuICBlcnJvcj86IHN0cmluZ1xufVxuXG5leHBvcnQgY2xhc3MgQ2xhdWRlQVBJIHtcbiAgcHJpdmF0ZSBiYXNlVVJMOiBzdHJpbmdcblxuICBjb25zdHJ1Y3RvcihiYXNlVVJMOiBzdHJpbmcgPSBBUElfQkFTRV9VUkwpIHtcbiAgICB0aGlzLmJhc2VVUkwgPSBiYXNlVVJMXG4gIH1cblxuICBhc3luYyBjaGF0KHJlcXVlc3Q6IENoYXRSZXF1ZXN0KTogUHJvbWlzZTxDaGF0UmVzcG9uc2U+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVSTH0vY2hhdGAsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpLFxuICAgIH0pXG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKVxuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgfVxuXG4gIGFzeW5jIGNoYXRTdHJlYW0ocmVxdWVzdDogQ2hhdFJlcXVlc3QpOiBQcm9taXNlPFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVUkx9L2NoYXRgLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IC4uLnJlcXVlc3QsIHN0cmVhbTogdHJ1ZSB9KSxcbiAgICB9KVxuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YClcbiAgICB9XG5cbiAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcmVzcG9uc2UgYm9keScpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlLmJvZHlcbiAgfVxuXG4gIGFzeW5jIGhlYWx0aGNhcmVBbmFseXplKHRhc2s6IHN0cmluZywgY29udGV4dD86IGFueSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9oZWFsdGhjYXJlL2FuYWx5emVgLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHRhc2ssIGNvbnRleHQgfSksXG4gICAgfSlcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICB9XG5cbiAgYXN5bmMgZGVlcFJlc2VhcmNoKG1lc3NhZ2VzOiBDaGF0TWVzc2FnZVtdLCBzZXNzaW9uSWQ6IHN0cmluZywgdXNlcklkOiBzdHJpbmcpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVSTH0vYXBpL3J1bl9zc2VgLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgdXNlcklkLFxuICAgICAgICBuZXdNZXNzYWdlOiB7XG4gICAgICAgICAgcGFydHM6IG1lc3NhZ2VzLm1hcChtc2cgPT4gKHsgdGV4dDogbXNnLmNvbnRlbnQgfSkpLFxuICAgICAgICAgIHJvbGU6IG1lc3NhZ2VzW21lc3NhZ2VzLmxlbmd0aCAtIDFdLnJvbGVcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgfSlcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlLmJvZHlcbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3QgY2xhdWRlQVBJID0gbmV3IENsYXVkZUFQSSgpXG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBwYXJzZSBTU0Ugc3RyZWFtXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIHBhcnNlU1NFU3RyZWFtKHN0cmVhbTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4pIHtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpXG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKVxuICBsZXQgYnVmZmVyID0gJydcblxuICB0cnkge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpXG4gICAgICBpZiAoZG9uZSkgYnJlYWtcblxuICAgICAgYnVmZmVyICs9IGRlY29kZXIuZGVjb2RlKHZhbHVlLCB7IHN0cmVhbTogdHJ1ZSB9KVxuICAgICAgY29uc3QgbGluZXMgPSBidWZmZXIuc3BsaXQoJ1xcbicpXG4gICAgICBidWZmZXIgPSBsaW5lcy5wb3AoKSB8fCAnJ1xuXG4gICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgaWYgKGxpbmUuc3RhcnRzV2l0aCgnZGF0YTogJykpIHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gbGluZS5zbGljZSg2KS50cmltKClcbiAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhICE9PSAnW0RPTkVdJykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgeWllbGQgSlNPTi5wYXJzZShkYXRhKVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcGFyc2UgU1NFIGRhdGE6JywgZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVhZGVyLnJlbGVhc2VMb2NrKClcbiAgfVxufSAiXSwibmFtZXMiOlsiQVBJX0JBU0VfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJDbGF1ZGVBUEkiLCJjaGF0IiwicmVxdWVzdCIsInJlc3BvbnNlIiwiZmV0Y2giLCJiYXNlVVJMIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwib2siLCJFcnJvciIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJqc29uIiwiY2hhdFN0cmVhbSIsInN0cmVhbSIsImhlYWx0aGNhcmVBbmFseXplIiwidGFzayIsImNvbnRleHQiLCJkZWVwUmVzZWFyY2giLCJtZXNzYWdlcyIsInNlc3Npb25JZCIsInVzZXJJZCIsIm5ld01lc3NhZ2UiLCJwYXJ0cyIsIm1hcCIsIm1zZyIsInRleHQiLCJjb250ZW50Iiwicm9sZSIsImxlbmd0aCIsImNvbnN0cnVjdG9yIiwiY2xhdWRlQVBJIiwicGFyc2VTU0VTdHJlYW0iLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJidWZmZXIiLCJkb25lIiwidmFsdWUiLCJyZWFkIiwiZGVjb2RlIiwibGluZXMiLCJzcGxpdCIsInBvcCIsImxpbmUiLCJzdGFydHNXaXRoIiwiZGF0YSIsInNsaWNlIiwidHJpbSIsInBhcnNlIiwiZSIsImNvbnNvbGUiLCJlcnJvciIsInJlbGVhc2VMb2NrIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ })

});